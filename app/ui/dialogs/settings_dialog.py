from PyQt6.QtWidgets import (
    QDialog, QHBoxLayout, QListWidget, QFrame, QStackedWidget, QVBoxLayout,
    QDialogButtonBox, QWidget, QGroupBox, QFormLayout, QPushButton, QLabel,
    QCheckBox, QSpinBox, QComboBox, QTableWidget, QHeaderView, QTableWidgetItem,
    QDoubleSpinBox, QMessageBox, QColorDialog, QAbstractSpinBox, QTabWidget,
    QSlider, QScrollArea, QSizePolicy
)
from PyQt6.QtCore import (
    Qt
)

try:
    import pyqtgraph as pg
    PYQTGRAPH_AVAILABLE = True
except ImportError:
    PYQTGRAPH_AVAILABLE = False

import math
import numpy as np

from app.core.models.project import current_project
from app.core.models.settings import RECEPTION_PRESETS, ReceptionModelConfig, ARPATrackConfig

class SettingsDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Settings")
        self.resize(900, 520)
        
        main_h = QHBoxLayout(self)
        self.list_widget = QListWidget()
        self.list_widget.addItems(["Appearance", "Reception Model", "Object", "Signal", "Simulation"])
        self.list_widget.setFixedWidth(150)
        
        line = QFrame()
        line.setFrameShape(QFrame.Shape.VLine)
        line.setFrameShadow(QFrame.Shadow.Sunken)
        
        self.stack = QStackedWidget()
        
        main_h.addWidget(self.list_widget)
        main_h.addWidget(line)
        main_h.addWidget(self.stack)
        
        self.init_appearance()
        self.init_dropout()
        self.init_object()
        self.init_signal()
        self.init_simulation()
        
        self.list_widget.currentRowChanged.connect(self.stack.setCurrentIndex)
        
        btn_layout = QVBoxLayout()
        bb = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok)
        bb.accepted.connect(self.accept)
        btn_layout.addStretch()
        btn_layout.addWidget(bb)
        main_h.addLayout(btn_layout)

    def init_appearance(self):
        w = QWidget()
        main_layout = QVBoxLayout(w)
        
        # --- Group 1: Object Colors ---
        grp_obj = QGroupBox("Object Colors")
        l_obj = QFormLayout(grp_obj)
        
        self.btn_own = QPushButton()
        self.btn_own.setFixedSize(25, 25)
        self.btn_own.setStyleSheet(f"background-color: {current_project.settings.own_color}")
        self.btn_own.clicked.connect(lambda: self.pick_color(self.btn_own, "own_color"))
        
        own_label = QLabel("Own Ship Color:")
        own_label.setToolTip("Set the color for Own Ship path and points.")
        l_obj.addRow(own_label, self.btn_own)

        self.btn_tgt = QPushButton()
        self.btn_tgt.setFixedSize(25, 25)
        self.btn_tgt.setStyleSheet(f"background-color: {current_project.settings.target_color}")
        self.btn_tgt.clicked.connect(lambda: self.pick_color(self.btn_tgt, "target_color"))
        
        tgt_label = QLabel("Target Ship Color:")
        tgt_label.setToolTip("Set the color for Target Ship path and points.")
        l_obj.addRow(tgt_label, self.btn_tgt)
        
        self.btn_rand_c = QPushButton()
        self.btn_rand_c.setFixedSize(25, 25)
        self.btn_rand_c.setStyleSheet(f"background-color: {current_project.settings.random_color}")
        self.btn_rand_c.clicked.connect(lambda: self.pick_color(self.btn_rand_c, "random_color"))
        
        rand_label = QLabel("Random Target Color:")
        rand_label.setToolTip("Set the color for Random Targets generated by RTG.")
        l_obj.addRow(rand_label, self.btn_rand_c)
        
        main_layout.addWidget(grp_obj)

        # --- Group 2: Path & Visualization ---
        grp_path = QGroupBox("Path & Visualization")
        l_path = QFormLayout(grp_path)
        
        self.chk_speed_notes = QCheckBox()
        speed_notes_label = QLabel("Show Speed Notes:")
        self.chk_speed_notes.setChecked(current_project.settings.show_speed_notes)
        
        self.spin_path_th = QSpinBox()
        self.spin_path_th.setRange(1, 10)
        self.spin_path_th.setValue(current_project.settings.path_thickness)
        
        self.spin_travel_th = QSpinBox()
        self.spin_travel_th.setRange(1, 10)
        self.spin_travel_th.setValue(current_project.settings.traveled_path_thickness)
        
        self.btn_high_c = QPushButton()
        self.btn_high_c.setFixedSize(25, 25)
        self.btn_high_c.setStyleSheet(f"background-color: {current_project.settings.highlight_path_color}")
        self.btn_high_c.clicked.connect(lambda: self.pick_color(self.btn_high_c, "highlight_path_color"))

        l_path.addRow(speed_notes_label, self.chk_speed_notes)
        l_path.addRow("진행 예정 경로 두께 (점선):", self.spin_path_th)
        l_path.addRow("진행 경로 두께:", self.spin_travel_th)
        l_path.addRow("강조(Highlight) 색상:", self.btn_high_c)
        
        main_layout.addWidget(grp_path)

        # --- Group 3: UI & Theme ---
        grp_ui = QGroupBox("UI & Theme")
        l_ui = QFormLayout(grp_ui)

        theme_label = QLabel("테마 (Theme):")
        self.combo_theme = QComboBox()
        self.combo_theme.addItems(["System", "Light", "Dark"])
        self.combo_theme.setCurrentText(current_project.settings.theme_mode)

        self.btn_sel = QPushButton()
        self.btn_sel.setFixedSize(25, 25)
        self.btn_sel.setStyleSheet(f"background-color: {current_project.settings.select_color}")
        self.btn_sel.clicked.connect(lambda: self.pick_color(self.btn_sel, "select_color"))
        
        sel_color_label = QLabel("Selection Color:")
        sel_color_label.setToolTip("Color used when an object or path is selected.")

        self.btn_mask = QPushButton()
        self.btn_mask.setFixedSize(25, 25)
        self.btn_mask.setStyleSheet(f"background-color: {current_project.settings.mask_color}")
        self.btn_mask.clicked.connect(lambda: self.pick_color(self.btn_mask, "mask_color"))
        
        mask_color_label = QLabel("Latitude Mask Color:")
        mask_color_label.setToolTip("Color to mask invalid latitude areas (> ±90 degrees).")

        l_ui.addRow(theme_label, self.combo_theme)
        l_ui.addRow(sel_color_label, self.btn_sel)
        l_ui.addRow(mask_color_label, self.btn_mask)
        
        main_layout.addWidget(grp_ui)
        main_layout.addStretch()
        
        self.stack.addWidget(w)

    def init_dropout(self):
        """Reception Model (거리 기반 수신 모델) 탭 초기화"""
        w = QWidget()
        main_layout = QVBoxLayout(w)

        # 상단: 전체 활성화 체크박스와 프리셋
        top_layout = QHBoxLayout()

        self.chk_reception_enabled = QCheckBox("Distance-based reception model 사용")
        self.chk_reception_enabled.setChecked(current_project.settings.reception_model_enabled)
        self.chk_reception_enabled.stateChanged.connect(self._on_reception_enabled_changed)
        top_layout.addWidget(self.chk_reception_enabled)

        top_layout.addStretch()

        preset_label = QLabel("Preset:")
        top_layout.addWidget(preset_label)

        self.combo_preset = QComboBox()
        self.combo_preset.addItems(["Realistic (Default)", "Stable (Demo)", "Harsh (Stress)", "Custom"])
        preset_map = {"realistic": 0, "stable": 1, "harsh": 2, "custom": 3}
        self.combo_preset.setCurrentIndex(preset_map.get(current_project.settings.reception_preset, 0))
        self.combo_preset.currentIndexChanged.connect(self._on_preset_changed)
        top_layout.addWidget(self.combo_preset)

        self.btn_reset_preset = QPushButton("Reset to Preset")
        self.btn_reset_preset.clicked.connect(self._apply_preset)
        top_layout.addWidget(self.btn_reset_preset)

        main_layout.addLayout(top_layout)

        # 서브 탭 위젯
        self.reception_tabs = QTabWidget()

        # AIS 탭
        ais_tab = self._create_reception_tab("ais", current_project.settings.ais_reception)
        self.reception_tabs.addTab(ais_tab, "AIS")

        # Radar 탭
        radar_tab = self._create_reception_tab("radar", current_project.settings.radar_detect)
        self.reception_tabs.addTab(radar_tab, "Radar")

        # ARPA 탭 (추가 설정 포함)
        arpa_tab = self._create_reception_tab("arpa", current_project.settings.arpa_track, is_arpa=True)
        self.reception_tabs.addTab(arpa_tab, "ARPA")

        # Camera 탭
        camera_tab = self._create_reception_tab("camera", current_project.settings.camera_reception)
        self.reception_tabs.addTab(camera_tab, "Camera")

        # Preview 탭
        preview_tab = self._create_preview_tab()
        self.reception_tabs.addTab(preview_tab, "Preview")

        main_layout.addWidget(self.reception_tabs)

        # 기존 고정 확률 방식 (하위 호환성)
        legacy_group = QGroupBox("Legacy Dropout (when reception model disabled)")
        legacy_layout = QFormLayout(legacy_group)
        self.drop_spins = {}
        for key in ["AIVDM", "RATTM", "Camera"]:
            s = QDoubleSpinBox()
            s.setRange(0, 1)
            s.setSingleStep(0.01)
            s.setValue(current_project.settings.dropout_probs.get(key, 0.1))
            label = QLabel(f"{key} Dropout:")
            legacy_layout.addRow(label, s)
            self.drop_spins[key] = s
        main_layout.addWidget(legacy_group)

        self._on_reception_enabled_changed()
        self.stack.addWidget(w)

    def _create_reception_tab(self, tab_type: str, config, is_arpa: bool = False):
        """각 신호 타입별 수신 모델 탭 생성"""
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)

        tab_widget = QWidget()
        layout = QVBoxLayout(tab_widget)

        # Simple Settings 그룹
        simple_group = QGroupBox("Simple Settings")
        simple_layout = QFormLayout(simple_group)

        # d0: Max reliable range
        spin_d0 = QDoubleSpinBox()
        spin_d0.setRange(0, 200)
        spin_d0.setSingleStep(1)
        spin_d0.setDecimals(1)
        spin_d0.setSuffix(" NM")
        spin_d0.setValue(config.d0)
        spin_d0.valueChanged.connect(lambda v: self._update_preview())
        simple_layout.addRow("Max reliable range (d0):", spin_d0)

        # d1: Fade-out end
        spin_d1 = QDoubleSpinBox()
        spin_d1.setRange(0, 200)
        spin_d1.setSingleStep(1)
        spin_d1.setDecimals(1)
        spin_d1.setSuffix(" NM")
        spin_d1.setValue(config.d1)
        spin_d1.valueChanged.connect(lambda v: self._update_preview())
        simple_layout.addRow("Fade-out end (d1):", spin_d1)

        # p0: Near-range dropout
        spin_p0 = QDoubleSpinBox()
        spin_p0.setRange(0, 1)
        spin_p0.setSingleStep(0.01)
        spin_p0.setDecimals(2)
        spin_p0.setValue(config.p0)
        spin_p0.valueChanged.connect(lambda v: self._update_preview())
        simple_layout.addRow("Near-range dropout (p0):", spin_p0)

        # p1: At d1 dropout
        spin_p1 = QDoubleSpinBox()
        spin_p1.setRange(0, 1)
        spin_p1.setSingleStep(0.01)
        spin_p1.setDecimals(2)
        spin_p1.setValue(config.p1)
        spin_p1.valueChanged.connect(lambda v: self._update_preview())
        simple_layout.addRow("At d1 dropout (p1):", spin_p1)

        # Full block at d1
        chk_full_block = QCheckBox()
        chk_full_block.setChecked(config.full_block_at_d1)
        chk_full_block.stateChanged.connect(lambda v: self._update_preview())
        simple_layout.addRow("d >= d1 에서 완전 차단:", chk_full_block)

        layout.addWidget(simple_group)

        # Advanced Settings 그룹 (접힘)
        adv_group = QGroupBox("Advanced Settings")
        adv_group.setCheckable(True)
        adv_group.setChecked(False)
        adv_layout = QFormLayout(adv_group)

        # Curve type
        combo_curve = QComboBox()
        combo_curve.addItems(["smoothstep", "linear", "logistic"])
        combo_curve.setCurrentText(config.curve_type)
        combo_curve.currentTextChanged.connect(lambda v: self._update_preview())
        adv_layout.addRow("Curve type:", combo_curve)

        # Burst loss
        chk_burst = QCheckBox("Enable burst loss")
        chk_burst.setChecked(config.burst_enabled)
        adv_layout.addRow("", chk_burst)

        spin_burst_min = QDoubleSpinBox()
        spin_burst_min.setRange(0.1, 60)
        spin_burst_min.setValue(config.burst_min_sec)
        spin_burst_min.setSuffix(" s")
        adv_layout.addRow("Min burst length:", spin_burst_min)

        spin_burst_max = QDoubleSpinBox()
        spin_burst_max.setRange(0.1, 60)
        spin_burst_max.setValue(config.burst_max_sec)
        spin_burst_max.setSuffix(" s")
        adv_layout.addRow("Max burst length:", spin_burst_max)

        spin_burst_mult = QDoubleSpinBox()
        spin_burst_mult.setRange(0.1, 10)
        spin_burst_mult.setValue(config.burst_trigger_mult)
        adv_layout.addRow("Burst trigger multiplier:", spin_burst_mult)

        # ARPA 전용 설정
        spin_coast = None
        spin_reacquire = None
        if is_arpa:
            arpa_config = config  # ARPATrackConfig
            spin_coast = QDoubleSpinBox()
            spin_coast.setRange(0, 60)
            spin_coast.setValue(arpa_config.coast_time_sec)
            spin_coast.setSuffix(" s")
            adv_layout.addRow("Coast time (track hold):", spin_coast)

            spin_reacquire = QDoubleSpinBox()
            spin_reacquire.setRange(0, 1)
            spin_reacquire.setSingleStep(0.05)
            spin_reacquire.setValue(arpa_config.reacquire_prob)
            adv_layout.addRow("Reacquire probability:", spin_reacquire)

        layout.addWidget(adv_group)
        layout.addStretch()

        # 위젯 참조 저장
        if not hasattr(self, 'reception_widgets'):
            self.reception_widgets = {}

        self.reception_widgets[tab_type] = {
            'd0': spin_d0, 'd1': spin_d1, 'p0': spin_p0, 'p1': spin_p1,
            'full_block': chk_full_block, 'curve': combo_curve,
            'burst_enabled': chk_burst, 'burst_min': spin_burst_min,
            'burst_max': spin_burst_max, 'burst_mult': spin_burst_mult,
            'coast': spin_coast, 'reacquire': spin_reacquire
        }

        scroll.setWidget(tab_widget)
        return scroll

    def _create_preview_tab(self):
        """Preview 탭 생성 (pyqtgraph 그래프)"""
        tab_widget = QWidget()
        layout = QVBoxLayout(tab_widget)

        # 거리 슬라이더
        slider_layout = QHBoxLayout()
        slider_label = QLabel("Distance:")
        slider_layout.addWidget(slider_label)

        self.preview_slider = QSlider(Qt.Orientation.Horizontal)
        self.preview_slider.setRange(0, 60)
        self.preview_slider.setValue(30)
        self.preview_slider.valueChanged.connect(self._on_preview_slider_changed)
        slider_layout.addWidget(self.preview_slider)

        self.preview_dist_label = QLabel("30 NM")
        self.preview_dist_label.setMinimumWidth(60)
        slider_layout.addWidget(self.preview_dist_label)

        layout.addLayout(slider_layout)

        # pyqtgraph 그래프
        if PYQTGRAPH_AVAILABLE:
            self.preview_plot = pg.PlotWidget()
            self.preview_plot.setBackground('w')
            self.preview_plot.setLabel('left', 'Dropout Probability', units='%')
            self.preview_plot.setLabel('bottom', 'Distance', units='NM')
            self.preview_plot.setYRange(0, 100)
            self.preview_plot.setXRange(0, 60)
            self.preview_plot.addLegend()
            self.preview_plot.showGrid(x=True, y=True, alpha=0.3)

            # 플롯 라인
            self.plot_lines = {
                'ais': self.preview_plot.plot(pen=pg.mkPen('b', width=2), name='AIS'),
                'radar': self.preview_plot.plot(pen=pg.mkPen('g', width=2), name='Radar'),
                'arpa': self.preview_plot.plot(pen=pg.mkPen(color=(255, 165, 0), width=2), name='ARPA'),
                'camera': self.preview_plot.plot(pen=pg.mkPen('r', width=2), name='Camera'),
            }

            # 수직선 (현재 거리)
            self.preview_vline = pg.InfiniteLine(pos=30, angle=90, pen=pg.mkPen('k', width=1, style=Qt.PenStyle.DashLine))
            self.preview_plot.addItem(self.preview_vline)

            layout.addWidget(self.preview_plot)
        else:
            no_graph_label = QLabel("pyqtgraph not installed. Install with: pip install pyqtgraph")
            no_graph_label.setStyleSheet("color: red; font-style: italic;")
            layout.addWidget(no_graph_label)

        # 현재 거리에서의 확률 표시
        prob_group = QGroupBox("At Current Distance")
        prob_layout = QFormLayout(prob_group)

        self.prob_labels = {}
        for key, name in [('ais', 'P_drop(AIS)'), ('radar', 'P_drop(Radar)'),
                          ('arpa', 'P_drop(ARPA)'), ('camera', 'P_drop(Camera)')]:
            label = QLabel("0.0%")
            label.setMinimumWidth(80)
            prob_layout.addRow(f"{name}:", label)
            self.prob_labels[key] = label

        layout.addWidget(prob_group)

        return tab_widget

    def _calculate_dropout_prob(self, distance, config) -> float:
        """거리 기반 드롭아웃 확률 계산"""
        d, d0, d1, p0, p1 = distance, config.d0, config.d1, config.p0, config.p1

        if d <= d0:
            return p0
        elif d >= d1:
            return 1.0 if config.full_block_at_d1 else p1
        else:
            t = (d - d0) / (d1 - d0) if (d1 - d0) > 0 else 0

            if config.curve_type == "linear":
                factor = t
            elif config.curve_type == "logistic":
                factor = 1 / (1 + math.exp(-10 * (t - 0.5)))
            else:  # smoothstep
                factor = t * t * (3 - 2 * t)

            return p0 + (p1 - p0) * factor

    def _get_current_config(self, tab_type: str):
        """현재 UI 값으로 ReceptionModelConfig 객체 생성"""
        widgets = self.reception_widgets.get(tab_type, {})
        if not widgets:
            return None

        if tab_type == 'arpa':
            config = ARPATrackConfig(
                d0=widgets['d0'].value(),
                d1=widgets['d1'].value(),
                p0=widgets['p0'].value(),
                p1=widgets['p1'].value(),
                full_block_at_d1=widgets['full_block'].isChecked(),
                curve_type=widgets['curve'].currentText(),
                burst_enabled=widgets['burst_enabled'].isChecked(),
                burst_min_sec=widgets['burst_min'].value(),
                burst_max_sec=widgets['burst_max'].value(),
                burst_trigger_mult=widgets['burst_mult'].value(),
                coast_time_sec=widgets['coast'].value() if widgets['coast'] else 5.0,
                reacquire_prob=widgets['reacquire'].value() if widgets['reacquire'] else 0.8
            )
        else:
            config = ReceptionModelConfig(
                d0=widgets['d0'].value(),
                d1=widgets['d1'].value(),
                p0=widgets['p0'].value(),
                p1=widgets['p1'].value(),
                full_block_at_d1=widgets['full_block'].isChecked(),
                curve_type=widgets['curve'].currentText(),
                burst_enabled=widgets['burst_enabled'].isChecked(),
                burst_min_sec=widgets['burst_min'].value(),
                burst_max_sec=widgets['burst_max'].value(),
                burst_trigger_mult=widgets['burst_mult'].value()
            )
        return config

    def _update_preview(self):
        """Preview 그래프 업데이트"""
        if not PYQTGRAPH_AVAILABLE or not hasattr(self, 'preview_plot'):
            return

        distances = np.linspace(0, 60, 200)

        for tab_type in ['ais', 'radar', 'arpa', 'camera']:
            config = self._get_current_config(tab_type)
            if config:
                probs = [self._calculate_dropout_prob(d, config) * 100 for d in distances]
                self.plot_lines[tab_type].setData(distances, probs)

        # 현재 거리에서의 확률 업데이트
        current_dist = self.preview_slider.value()
        for tab_type in ['ais', 'radar', 'arpa', 'camera']:
            config = self._get_current_config(tab_type)
            if config:
                prob = self._calculate_dropout_prob(current_dist, config) * 100
                self.prob_labels[tab_type].setText(f"{prob:.1f}%")

    def _on_preview_slider_changed(self, value):
        """Preview 슬라이더 값 변경"""
        self.preview_dist_label.setText(f"{value} NM")
        if PYQTGRAPH_AVAILABLE and hasattr(self, 'preview_vline'):
            self.preview_vline.setPos(value)
        self._update_preview()

    def _on_reception_enabled_changed(self):
        """수신 모델 활성화/비활성화"""
        enabled = self.chk_reception_enabled.isChecked()
        self.reception_tabs.setEnabled(enabled)
        self.combo_preset.setEnabled(enabled)
        self.btn_reset_preset.setEnabled(enabled)

    def _on_preset_changed(self, index):
        """프리셋 변경 시 Custom으로 자동 전환하지 않음 (Reset 버튼 사용)"""
        pass

    def _apply_preset(self):
        """선택된 프리셋 적용"""
        preset_names = ["realistic", "stable", "harsh", "custom"]
        preset_name = preset_names[self.combo_preset.currentIndex()]

        if preset_name == "custom":
            return

        preset = RECEPTION_PRESETS.get(preset_name, {})

        # AIS
        if 'ais' in preset and 'ais' in self.reception_widgets:
            self._apply_preset_to_tab('ais', preset['ais'])

        # Radar
        if 'radar_detect' in preset and 'radar' in self.reception_widgets:
            self._apply_preset_to_tab('radar', preset['radar_detect'])

        # ARPA
        if 'arpa_track' in preset and 'arpa' in self.reception_widgets:
            self._apply_preset_to_tab('arpa', preset['arpa_track'])

        # Camera
        if 'camera' in preset and 'camera' in self.reception_widgets:
            self._apply_preset_to_tab('camera', preset['camera'])

        self._update_preview()

    def _apply_preset_to_tab(self, tab_type: str, preset_data: dict):
        """프리셋 데이터를 탭에 적용"""
        widgets = self.reception_widgets.get(tab_type, {})
        if not widgets:
            return

        if 'd0' in preset_data:
            widgets['d0'].setValue(preset_data['d0'])
        if 'd1' in preset_data:
            widgets['d1'].setValue(preset_data['d1'])
        if 'p0' in preset_data:
            widgets['p0'].setValue(preset_data['p0'])
        if 'p1' in preset_data:
            widgets['p1'].setValue(preset_data['p1'])
        if 'coast_time_sec' in preset_data and widgets.get('coast'):
            widgets['coast'].setValue(preset_data['coast_time_sec'])
        if 'reacquire_prob' in preset_data and widgets.get('reacquire'):
            widgets['reacquire'].setValue(preset_data['reacquire_prob'])

    def init_object(self):
        w = QWidget()
        l = QVBoxLayout(w)
        
        own_ship_group = QGroupBox("Select Own Ship")
        form_layout = QFormLayout(own_ship_group)
        self.spin_own = QSpinBox()
        self.spin_own.setRange(0, 999)
        self.spin_own.setValue(current_project.settings.own_ship_idx)
        self.spin_own.setButtonSymbols(QAbstractSpinBox.ButtonSymbols.NoButtons)
        self.spin_own.setMaximumWidth(100)
        label = QLabel("Own Ship Index:")
        label.setToolTip("Index (ID) of the ship to be treated as Own Ship. Own Ship generates additional signals like GPRMC.")
        form_layout.addRow(label, self.spin_own)
        l.addWidget(own_ship_group)

        # --- New: Random Target Settings ---
        random_target_group = QGroupBox("Random Target Settings")
        rtg_layout = QFormLayout(random_target_group)

        self.spin_speed_var = QDoubleSpinBox()
        self.spin_speed_var.setRange(0.0, 100.0)
        self.spin_speed_var.setSingleStep(0.1)
        self.spin_speed_var.setDecimals(2)
        self.spin_speed_var.setValue(current_project.settings.speed_variance)

        label_speed_var = QLabel("Speed Variance (kn^2):")
        label_speed_var.setToolTip("Unified variance for wind/current effects. Applied to RTG initial speed and simulation loop noise.")
        rtg_layout.addRow(label_speed_var, self.spin_speed_var)

        l.addWidget(random_target_group)
        # --- End New ---

        obj_group = QGroupBox("Object List")
        obj_layout = QVBoxLayout(obj_group)
        
        self.obj_table = QTableWidget()
        self.obj_table.setColumnCount(5)
        self.obj_table.setHorizontalHeaderLabels(["chk", "idx", "Type", "Name", "Generated"])
        self.obj_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.obj_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Fixed)
        self.obj_table.setColumnWidth(0, 40)
        self.obj_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
        self.obj_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.ResizeToContents)
        self.obj_table.verticalHeader().setSectionResizeMode(QHeaderView.ResizeMode.ResizeToContents)

        all_objects = sorted(
            [(s.idx, "Ship", s) for s in current_project.ships] + 
            [(a.id, "Area", a) for a in current_project.areas], 
            key=lambda x: x[0]
        )
        
        self.obj_table.setRowCount(len(all_objects))

        for row, (obj_id, obj_type, obj_data) in enumerate(all_objects):
            chk_item = QTableWidgetItem()
            chk_item.setFlags(Qt.ItemFlag.ItemIsUserCheckable | Qt.ItemFlag.ItemIsEnabled)
            chk_item.setCheckState(Qt.CheckState.Unchecked)
            self.obj_table.setItem(row, 0, chk_item)

            idx_item = QTableWidgetItem(str(obj_id))
            idx_item.setFlags(idx_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
            
            type_item = QTableWidgetItem(obj_type)
            type_item.setFlags(type_item.flags() & ~Qt.ItemFlag.ItemIsEditable)

            name_item = QTableWidgetItem(obj_data.name)
            if obj_type != "Ship":
                name_item.setFlags(name_item.flags() & ~Qt.ItemFlag.ItemIsEditable)

            gen_str = "-"
            if obj_type == "Ship":
                gen_str = "Yes" if obj_data.is_generated else "No"
            
            gen_item = QTableWidgetItem(gen_str)
            gen_item.setFlags(gen_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
            if gen_str == "Yes": gen_item.setForeground(Qt.GlobalColor.green)

            self.obj_table.setItem(row, 1, idx_item)
            self.obj_table.setItem(row, 2, type_item)
            self.obj_table.setItem(row, 3, name_item)
            self.obj_table.setItem(row, 4, gen_item)

        obj_layout.addWidget(self.obj_table)
        
        self.btn_del_checked = QPushButton("Delete Checked Objects")
        self.btn_del_checked.clicked.connect(self.delete_checked_objects)
        obj_layout.addWidget(self.btn_del_checked)
        
        l.addWidget(obj_group)
        self.stack.addWidget(w)
        
    def delete_checked_objects(self):
        rows_to_del = []
        for row in range(self.obj_table.rowCount()):
            item = self.obj_table.item(row, 0)
            if item and item.checkState() == Qt.CheckState.Checked:
                rows_to_del.append(row)
        
        if not rows_to_del:
            QMessageBox.information(self, "Info", "No objects selected.")
            return

        if QMessageBox.question(self, "Delete Objects", f"Delete {len(rows_to_del)} objects?", 
                                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No) != QMessageBox.StandardButton.Yes:
            return

        # Get IDs to delete
        ids_to_del = [] # list of (id, type)
        for row in rows_to_del:
            oid = int(self.obj_table.item(row, 1).text())
            otype = self.obj_table.item(row, 2).text()
            ids_to_del.append((oid, otype))
            
        # Remove from project
        for oid, otype in ids_to_del:
            if otype == "Ship":
                current_project.ships = [s for s in current_project.ships if s.idx != oid]
            elif otype == "Area":
                current_project.areas = [a for a in current_project.areas if a.id != oid]
        
        # Remove from table (reverse order)
        for row in sorted(rows_to_del, reverse=True):
            self.obj_table.removeRow(row)
            
        QMessageBox.information(self, "Deleted", "Deleted.")

    def init_signal(self):
        w = QWidget()
        layout = QVBoxLayout(w)
        
        info_label = QLabel("Set noise levels for each signal type.")
        info_label.setToolTip("Set small fluctuations (noise) for each ship and signal type to increase realism.")
        info_label.setStyleSheet("font-style: italic; color: #555;")
        layout.addWidget(info_label)

        # --- New: AIS Fragment Probabilities ---
        ais_frag_group = QGroupBox("AIS Message Fragment Probabilities (1-5 fragments)")
        ais_frag_layout = QFormLayout(ais_frag_group)

        self.ais_frag_spins = []
        for i in range(5):
            s = QDoubleSpinBox()
            s.setRange(0.0, 100.0) # Probabilities can be relative, so a wider range
            s.setSingleStep(0.1)
            s.setDecimals(2)
            s.setValue(current_project.settings.ais_fragment_probs[i])
            
            label = QLabel(f"{i+1} Fragment Probability:")
            label.setToolTip(f"Relative probability of generating an AIS message with {i+1} fragments.")
            ais_frag_layout.addRow(label, s)
            self.ais_frag_spins.append(s)
        
        layout.addWidget(ais_frag_group)
        # --- End New ---

        self.signal_noise_table = QTableWidget()
        self.talkers = ["AIVDM", "RATTM", "Camera"]
        ships = current_project.ships
        
        self.signal_noise_table.setRowCount(len(ships) + 1)
        self.signal_noise_table.setColumnCount(len(self.talkers) + 1)

        self.signal_noise_table.setHorizontalHeaderLabels(["Ctrl"] + self.talkers)
        self.signal_noise_table.setVerticalHeaderLabels(["ALL"] + [s.name for s in ships])

        for r in range(self.signal_noise_table.rowCount()):
            for c in range(self.signal_noise_table.columnCount()):
                val = 0.001
                if r > 0 and c > 0:
                    ship = ships[r - 1]
                    talker = self.talkers[c - 1]
                    val = ship.variances.get(talker, 0.001)

                spin = self._create_signal_noise_cell(val)
                spin.setProperty("row", r)
                spin.setProperty("col", c)
                spin.valueChanged.connect(self.on_signal_noise_changed)
                self.signal_noise_table.setCellWidget(r, c, spin)

        self.signal_noise_table.verticalHeader().setSectionResizeMode(QHeaderView.ResizeMode.ResizeToContents)
        self.signal_noise_table.setColumnWidth(0, 40)
        self.signal_noise_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Fixed)
        for i in range(1, self.signal_noise_table.columnCount()):
            self.signal_noise_table.horizontalHeader().setSectionResizeMode(i, QHeaderView.ResizeMode.Stretch)
        
        layout.addWidget(self.signal_noise_table)
        self.stack.addWidget(w)

    def init_simulation(self):
        w = QWidget()
        l = QFormLayout(w)

        # Placeholder - simulation settings can be added here in the future

        self.stack.addWidget(w)

    def _create_signal_noise_cell(self, value):
        spin = QDoubleSpinBox()
        spin.setRange(0, 1.0)
        spin.setSingleStep(0.001)
        spin.setDecimals(5)
        spin.setValue(value)
        spin.setButtonSymbols(QAbstractSpinBox.ButtonSymbols.NoButtons)
        spin.lineEdit().setAlignment(Qt.AlignmentFlag.AlignCenter)
        return spin

    def on_signal_noise_changed(self, value):
        sender_spin = self.sender()
        if not sender_spin: return

        r = sender_spin.property("row")
        c = sender_spin.property("col")

        table = self.signal_noise_table
        ships = current_project.ships

        rows_model = [r] if r > 0 else range(1, len(ships) + 1)
        cols_model = [c] if c > 0 else range(1, len(self.talkers) + 1)
        if r == 0 and c == 0:
            rows_model = range(1, len(ships) + 1)
            cols_model = range(1, len(self.talkers) + 1)

        for row_idx in rows_model:
            for col_idx in cols_model:
                ship = ships[row_idx - 1]
                talker = self.talkers[col_idx - 1]
                ship.variances[talker] = value

        if r == 0 or c == 0:
            rows_ui = range(table.rowCount()) if r == 0 else [r]
            cols_ui = range(table.columnCount()) if c == 0 else [c]
            if r == 0 and c == 0:
                rows_ui = range(table.rowCount())
                cols_ui = range(table.columnCount())

            for row in rows_ui:
                for col in cols_ui:
                    if row == r and col == c: continue
                    self._set_signal_noise_spinbox(row, col, value)
    
    def _set_signal_noise_spinbox(self, r, c, value):
        widget = self.signal_noise_table.cellWidget(r, c)
        if widget and isinstance(widget, QDoubleSpinBox):
            widget.blockSignals(True)
            widget.setValue(value)
            widget.blockSignals(False)

    def pick_color(self, btn, attr):
        c = QColorDialog.getColor()
        if c.isValid():
            setattr(current_project.settings, attr, c.name())
            btn.setStyleSheet(f"background-color: {c.name()}")

    def apply_changes(self):
        for row in range(self.obj_table.rowCount()):
            obj_id = int(self.obj_table.item(row, 1).text())
            obj_type = self.obj_table.item(row, 2).text()
            
            new_name = self.obj_table.item(row, 3).text()

            if obj_type == "Ship":
                obj = current_project.get_ship_by_idx(obj_id)
                if obj:
                    obj.name = new_name
            elif obj_type == "Area":
                obj = current_project.get_area_by_id(obj_id)
                # Area name update if needed, but currently read-only in table logic above for non-ships

        current_project.settings.show_speed_notes = self.chk_speed_notes.isChecked()
        current_project.settings.theme_mode = self.combo_theme.currentText()
        current_project.settings.own_ship_idx = self.spin_own.value()
        current_project.settings.speed_variance = self.spin_speed_var.value()
        current_project.settings.path_thickness = self.spin_path_th.value()
        current_project.settings.traveled_path_thickness = self.spin_travel_th.value()
        for k, s in self.drop_spins.items():
            current_project.settings.dropout_probs[k] = s.value()

        # Reception Model 설정 저장
        current_project.settings.reception_model_enabled = self.chk_reception_enabled.isChecked()
        preset_names = ["realistic", "stable", "harsh", "custom"]
        current_project.settings.reception_preset = preset_names[self.combo_preset.currentIndex()]

        # AIS reception config
        ais_config = self._get_current_config('ais')
        if ais_config:
            current_project.settings.ais_reception = ais_config

        # Radar detect config
        radar_config = self._get_current_config('radar')
        if radar_config:
            current_project.settings.radar_detect = radar_config

        # ARPA track config
        arpa_config = self._get_current_config('arpa')
        if arpa_config:
            current_project.settings.arpa_track = arpa_config

        # Camera reception config
        camera_config = self._get_current_config('camera')
        if camera_config:
            current_project.settings.camera_reception = camera_config

        for i, s in enumerate(self.ais_frag_spins):
            current_project.settings.ais_fragment_probs[i] = s.value()

